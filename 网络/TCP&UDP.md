## TCP&UDP

- TCP和UDP 是和端口绑定的。（Socket套接字）

- ### UDP

  - UDP是不具有可靠性的数据报传输协议。细微的处理它会叫给上层的应用去完成。再UDP的情况下，虽然可以确保发送消息的大小、却不能保证消息一定会到达，因此，应用有时会根据自己的需要进行重发处理。

- ### TCP

  - 通过序列号与确认应答提高可靠性

    - 在TCP中，当发送端的数据到达接受端时，接收端主机会返回一个已收到消息的通知，这个消息叫做确认应答（ACK）
    - 如是发送端发送数据途中丢失或者接收端返回的消息途中丢失，过一段时间后，发送端会重新发送一遍。
      - 情况一：发送端的数据没有送到，会触发重新发送
      - 情况二：接收端返回的消息，延迟到达或者丢失，发送端也会重新发送，这就造成了接收端重复收到相同的消息。为此就引入了序列号
        - 序列号：发送端发送的数据每字节都有一个序列号，当接受端接收到消息以后，会返回一个下一个应该接受的序列号作为应答。

  - 重发超时计算

    - 根据每次数据往返的时间及其偏差计算。将这个往返时间和偏差相加重发超时的时间，就是比这个总和大一点。

  - 连接管理（三次握手、四次挥手）

    - ### 三次握手

      ![1568645169458](C:\Users\侯泽明\AppData\Roaming\Typora\typora-user-images\1568645169458.png)

      （1）第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。

      （2）第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。

      （3）第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。

    - ### 四次挥手

      - ![1568645231702](C:\Users\侯泽明\AppData\Roaming\Typora\typora-user-images\1568645231702.png)

        由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。

         

        （1）第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。

        （2）第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。

        （3）第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。

        （4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。

      - #### 为什么建立连接是三次握手，而关闭连接却是四次挥手呢？

        这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。

      - ### 四次挥手为什么要等待2MLS时间

        主要有两个原因
        1. 实现TCP可靠的终止连接
        在进行四次挥手的时候, 最后的ACK是由客户端主动发送的, 如果这个ACK最终丢失, 服务端将重发FIN, 因此客户端必须维护状态信息允许服务端重发FIN, 如果不维护这个状态信息, 服务器将出现错误, 为了实现正常的终止, 客户端必须等待2MSL的时间.

        2. 允许本次连接的老的数据报在网络中消逝
        MSL是一个IP数据包能在网络上生存的最长时间, 超过这个时间会在网络中消失. 如果连接时被动方发送了一个FIN, 然后主动方回复了一个ACK, 然而这个ACK可能会丢失, 造成FIN重发, 如果没有TIME_WAIT, 最后被动方发送的那个FIN还在网络上, 而这时候恰巧连接2重新利用了连接1的所有元素, 刚刚建立好连接, 连接1推迟的FIN到达, 这个FIN可能会终止掉刚刚建立好的连接.

    - TCP以段位单位发送数据

      - TCP在建立连接的同时，可以确定发送数据包的单位（MSS），也就是IP中不会分片的最大长度。
      - 计算过程：在第一次握手，客户端会发送一个他的MSS；第二次握手服务器会返回一个他的MSS；第三次握手的时候就确定了MSS（客户端和服务器之间最小的MSS）。

    - 窗口控制

      - TCP以1个段位单位，每次一个段就进行一次确认应答的处理，包往返的时间越长，通信性能越低。

        为了解决这种情况引入了窗口概念。

      - 概述

         滑动窗口通俗来讲就是一种流量控制技术。   

         它本质上是描述接收方的TCP数据报缓冲区大小的数据，发送方根据这个数据来计算自己最多能发送多长的数据，如果发送方收到接收方的窗口大小为0的TCP数据报，那么发送方将停止发送数据，等到接收方发送窗口大小不为0的数据报的到来。

        这个机制使用了大量的缓冲区，又来保存每次发送的数据，当收到确认应答，这部分数据就会清除；否则就会重新发送。

    - 高速重发控制

      - 当客户端发送多段数据的时候，有一批数据丢失了，客户端会重复发送收到的确认应答，当发送端收到3次同样的确认应答序列号。就会重新发送这批数据。

    - 流控制

      - 为了解决网络流量的无端浪费，TCP提供了一种机制：流控制

      - 流控制：接收端主机向发送端主机通知自己可以接受数据的大小，于是发送端会发送不超过这个限度的数据。该限度大小就是窗口大小。TCP首部的一个字段用来通知窗口大小。窗口越大，吞吐量越大。

        也就是说发送端会根据接收端发送的窗口大小来对数据的量进行控制。

    - 拥塞控制

      - 慢开始
        发送方维持一个拥塞窗口, 拥塞窗口大小取决于网络的拥塞程度, 并且在动态的变化着. 发送方让自己的发送窗口等于拥塞窗口, 另外考虑到接收方的接收能力, 发送窗口可能小于拥塞窗口.
        慢开始算法的思路是: 不要一开始就发送大量数据, 先探测一下网络的拥塞程度, 也就是说由小到大的逐渐增加拥塞窗口大小.

      - 拥塞避免

        无论是在慢开始阶段还是拥塞避免阶段, 只要发送方判断网络出现拥塞
        (其根据就是没有收到确认), 就把慢开始门限设置为出现拥塞时的发送
        窗口大小的一半,然后把拥塞窗口设置为1, 然后执行慢开始算法.